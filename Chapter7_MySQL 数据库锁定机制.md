# MySQL 数据库锁定机制

1. MySQL 锁定机制简介

    MySQL 各存储引擎使用了三种类型（级别）的锁定机制：行级锁定，页级锁定和表级锁定。下面我们先分析一下MySQL 这三种锁定的特点和各自的优劣所在。

    * 行级锁定（row-level）

        锁定对象的颗粒度很小. 由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。

        行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。

    * 表级锁定（table-level）

        表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制.实现逻辑非常简单，带来的系统负面影响最小.获取锁和释放锁的速度很快. 锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。

    * 页级锁定（page-level）

        页级锁定是MySQL 中比较独特的一种锁定级别. 获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间. 另外，页级锁定和行级锁定一样，会发生死锁

    使用表级锁定的主要是MyISAM，Memory，CSV 等一些非事务性存储引擎. 使用行级锁定的主要是Innodb 存储引擎和NDB Cluster 存储引擎. 页级锁定主要是BerkeleyDB 存储引擎的锁定方式。

2. 各种锁定机制分析

    * 表级锁定

        表级锁定主要分为两种类型，一种是读锁定，另一种是写锁定

        • Current read-lock queue (lock->read)
        
        • Pending read-lock queue (lock->read_wait)
        
        • Current write-lock queue (lock->write)
        
        • Pending write-lock queue (lock->write_wait)

3. 合理利用锁机制优化MySQL

    * MyISAM 表锁优化建议

        尽可能让锁定的时间变短，然后就是让可能并发进行的操作尽可能的并发。

        1. 缩短锁定时间
        2. 分离能并行的操作 (concurrent_insert=0, 1, 2)
        3. 合理利用读写优先级 (low_priority_updates )

    * Innodb 行锁优化建议

        1. 尽可能让所有的数据检索都通过索引来完成
        2. 合理设计索引，让Innodb 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围
        3. 尽可能减少基于范围的数据检索过滤条
        4. 尽量控制事务的大小，减少锁定的资源量和锁定时间长度
        5. 在业务环境允许的情况下，尽量使用较低级别的事务隔离

        由于Innodb 的行级锁定和事务性，所以肯定会产生死锁

        1. 类似业务模块中，尽可能按照相同的访问顺序来访问，防止产生死锁；
        1. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
        1. 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率

    系统锁定争用情况查询

        > show status like 'table%';

        > show status like 'innodb_row_lock%';
